# Chapter.13 웹 애플리케이션과 영속성 관리
## 1. 트랜잭션 범위의 영속성 컨텍스트

### 스프링 기본 전략: 트랜잭션 범위의 영속성 컨텍스트
트랜잭션 시작 시 엔티티 매니저와 영속성 컨텍스트 생성, 종료 시 소멸
같은 트랜잭션 내에서는 동일한 영속성 컨텍스트 사용


### @Transactional과 AOP
@Transactional로 트랜잭션 시작, AOP 프록시가 관리
정상 종료: 플러시 후 커밋
예외 발생: 롤백 (플러시 X)


### 동작
Service 내 Repository들은 같은 엔티티 매니저와 영속성 컨텍스트 공유
다른 트랜잭션은 다른 영속성 컨텍스트 사용


### 주의
엔티티 매니저는 프록시 객체, 트랜잭션마다 별도 할당 → 멀티스레드 안전



## 2. 준영속 상태와 지연 로딩

준영속 상태
트랜잭션 종료 후 영속성 컨텍스트 소멸 → 엔티티는 준영속 상태
컨트롤러/뷰에서 변경 감지, 지연 로딩 불가 → LazyInitializationException 발생


문제
프레젠테이션 계층에서 데이터 수정은 책임 분리 위반, 유지보수 어려움


### 해결 방법
미리 로딩
글로벌 패치 전략: FetchType.LAZY → FetchType.EAGER
단점: N+1 문제, 불필요한 엔티티 로딩


JPQL 페치 조인: 필요한 엔티티 미리 로딩
단점: Repository 메서드 증가, 뷰와 논리적 의존성


강제 초기화: 트랜잭션 내 프록시 초기화 (예: member.team().getName())
단점: 서비스 계층에 프레젠테이션 로직 침투




## FACADE 계층
프레젠테이션과 도메인 분리, 프록시 초기화 처리
단점: 계층 추가, 위임 코드 증가




결론: 모든 방법은 번거로움, 논리적 의존성 증가 가능

## 3. OSIV (Open Session In View)

OSIV란: 영속성 컨텍스트를 뷰까지 유지
과거 OSIV (요청 당 트랜잭션)
요청 시작부터 종료까지 트랜잭션 유지
문제: 프레젠테이션 계층에서 엔티티 수정 가능
해결: 읽기 전용 인터페이스, 엔티티 래핑, DTO 반환 (코드량 증가)


### 스프링 OSIV
동작 과정
요청 시 영속성 컨텍스트 생성 (트랜잭션 X)
서비스에서 트랜잭션 시작, 커밋 시 플러시
트랜잭션 종료 후 영속성 컨텍스트 유지
요청 종료 시 영속성 컨텍스트 소멸


### 특징
트랜잭션 외 읽기 전용 (NonTransactional reads)
프레젠테이션 계층에서 수정 불가, 지연 로딩 가능




### 주의사항
프레젠테이션 계층에서 엔티티 수정 후 서비스 호출 시, 수정 데이터가 플러시로 DB 반영 가능
해결: 비즈니스 로직 호출 후 수정


원격 환경(JSON 응답)에서 지연 로딩 불가
해결: 필요한 데이터 미리 JSON에 포함




### 장점
준영속 상태 문제 해결
프레젠테이션 계층에서 지연 로딩 가능


### 단점
트랜잭션 관리 복잡성 주의 필요



### 핵심 요약

트랜잭션 범위의 영속성 컨텍스트: 트랜잭션과 생명주기 동일, 같은 트랜잭션 내 동일 컨텍스트<br>
준영속 상태: 트랜잭션 종료 후 지연 로딩 불가, 미리 로딩/강제 초기화/FACADE로 해결<br>
스프링 OSIV: 뷰까지 영속성 컨텍스트 유지, 읽기 전용으로 지연 로딩 가능, 프레젠테이션 수정 주의