# Chapter.16 트랜잭션과 락, 2차 캐시

> ### 📋 차례
> [1) 트랜잭션과 락](#1-트랜잭션과 락) <br>
> [2) 2차 캐시](#2-2차-캐시) <br>

<br>

## 1) 트랜잭션과 락

> ### 🔍 트랜잭션과 ACID 보장
> 1) **원자성(Atomicity)**: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하던가 실패해야 한다.
> 2) **일관성(Consistency)**: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야하 한다. _(데이터베이스에서 정한 무결성 제약 조건 만족)_
> 3) **격리성(Isolation)**: 동시에 실행되는 트랜잭션들이 서로에게 영향을 주지 못하도록 격리 _(동시에 같은 데이터를 수정하지 못하도록 해야함)_
> 4) **지속성(Durability)**: 트랜잭션을 성공적으로 끝내면 결과를 기록해야한다. 시스템에 문제가 발생해도 성공한 트랜잭션 내용을 복구해야 한다.

트랜잭션에서 격리성을 완벽하게 보장하기 위해서는 동시성 처리 성능이 매우 나빠짐.

> ### 💡트랜잭션 격리 수준 4단계
> 1) **`READ UNCOMMITTED`**: 커밋하지 않은 데이터를 읽을 수 있다.
>    * **`DIRTY READ`**: A 트랜잭션이 데이터를 수정하고 있을 때 커밋하지 않아도 B 트랜잭션이 수정 중인 데이터를 조회할 수 있다. 이떄 롤백시 정합성 문제 발생
> 2) **`READ COMMITTED`**: 커밋한 데이터만 읽을 수 있어 DIRTY READ가 발생하지 않는다.
>    * **`NON-REPEATABLE READ`**: A 트랜잭션이 데이터를 조회할 때 B 트랜잭션이 수정하고 커밋하면 A 트랜잭션이 회원을 조회했을 때 수정 전 데이터를 조회. (반복해서 같은 데이터를 읽을 수 없음)
> 3) **`REPEATABLE READ`**: 한번 조회한 데이터를 반복 조회해도 같은 데이터가 조회된다. (DIRTY READ와 NON-REPEATABLE READ가 발생하지 않음)
>    * **`PHANTOM READ`**: A 트랜잭션이 a집단을 조회 했을 때, B 트랜잭션이 데이터를 추가할 경우 추가된 상태인 a`가 조회됨
> 4) **`SERIALIZABLE`**: 가장 엄격한 트랜잭션으로 동시성 성능 저하

데이터베이스들은 보통 `READ COMMITTED` 격리 수준을 기본으로 함 <br>
더 높은 트랜잭션 격리 수준이 필요할 경우 데이터베이스 트랜잭션이 제공하는 잠금 기능 사용

> ### 💬 MVCC란?
> 하나의 데이터를 여러 버전으로 관리해서, 트랜잭션마다 자신에게 맞는 버전을 읽도록 함. 
> 읽기 작업(SELECT) 은 락 없이 수행 가능 (읽기 일관성 보장)
> 쓰기 작업(UPDATE, DELETE) 은 충돌 시 실패하거나 재시도

<br>

### 1️⃣ 두 번의 갱신 분실 문제
* 사용자 두명이 수정하던 중 사용자 A가 먼저 수정완료 버튼을 누른 후 B가 수정 버튼을 눌렀을 때, 결과적으로 B의 수정사항만 남게 되는 것
1) 마지막 커밋만 인정하기: 사용자 A의 내용은 무시하고 마지막에 커밋한 사용자 B의 내용만 인정한다.
2) 최초 커밋만 인정하기: 사용자 A가 이미 수정을 완료했으므로 사용자 B가 수정을 완료할 때 오류 발생.
3) 충돌하는 갱신 내용 병합하기: 사용자 A가 사용자 B의 수정사항을 병합한다.

기본은 마지막 커밋 인정하기 사용

<br>

### 2️⃣ `@Version`
```java
@Version
private Integer version;
```
* 엔티티에 버전 관리용 필드 추가
* 앤티티를 수정할 때마다 버전이 증가
* 엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외 발생 👉 **최초 커밋만 인정하기** 적용

* 데이터베이스 버전과 엔티티 버전이 같으면 데이터를 수정하면서 동시에 버전도 증가
* 버전은 엔티티의 값을 변경하면 증가
* 연관관계 필드는 외래 키를 관리하는 연관관계의 주인 필드를 수정할 때만 버전이 증가
* 벌크연산 외에는 개발자가 임의로 version 수정을 하면 안됨

### 3️⃣ JPA 락 사용
```java
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC);

Board board = em.find(Board.class, id);
em.lock(board, LockModeType.OPTIMISTIC);
```

|       | 낙관적 락                         | 비관적 락                                                    |
|-------|:------------------------------|----------------------------------------------------------|
| 특징    | 트랜잭션을 커밋하는 시점에 충돌 감지          | 엔티티가 아닌 스칼라 타입을 조회할 때도 사용 가능<br/>데이터를 수정하는 즉시 트랜잭션 충돌 감지 |


|       | 타입                            | 설명                                                                                            | 용도                                                            | 동작                                                          | 동작                                        |
|-------|:------------------------------|-----------------------------------------------------------------------------------------------|---------------------------------------------------------------|-------------------------------------------------------------|-------------------------------------------|
| 낙관적 락 | `OPTIMISTIC`                  | 엔티티를 조회만 해도 버전을 체크<br/> 한번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음 보장<br/>엔티티를 단순 조회해도 버전 확인 | 조회 시점부터 트랜잭션이 끝날 때까지 조회한 엔티티가 변경되지 않음 보장                      | 트랜잭션을 커밋할 때 버전 정보를 조회하여 현재와 같은지 검증<br/>같지 않으면 예외 발생         | `DIRTY READ`와 `NON-REPEATABLE READ`를 방지   |
| 낙관적 락 | `OPTIMISTIC_FORCE_INCREMENT`  | 낙관적락을 사용하면서 버전정보 강제 증가                                                                        | 연관관계로 이어진 엔티티 버전 정보 증가                                        | 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보 강제 증가(총 2번의 버전 증가)        | 강제로 버전을 증가해서 논리적인 단위의 엔티티 묶음을 버전 관리할 수 있음 |
| 비관적 락 | `PESSIMISTIC_READ`            | 데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용                                                          | -                                                             | -                                                           | -                                         |
| 비관적 락 | `PESSIMISTIC_WRITE`           | 비관적 락 일반 옵션                                                                                   | 데이터베이스에 쓰기 락을 건다.                                             | 데이터베이스 `select for update`를 사용하여 락을 건다.                     | `NON-REPEATABLE READ`를 방지                 |
| 비관적 락 | `PESSIMISTIC_FORCE_INCREMENT` | 비관적 락 + 버전 정보 강제 증가                                                                           | -                                                             | -                                                           | -                                         |
| 기타    | `NONE`                        | `@Version`이 적용된 필드만 있으면 락 옵션을 적용하지 않아도 낙관적 락 적용                                               | 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경도지 않아야 한다. <br/>조회시점부터 수정시점까지 보장 | 엔티티를 수정할 때 버전을 체크하면서 증가<br/> 데이터베이스의 버전 값이 현재 버전이 아니면 예외 발생 | 두 번의 갱신 분실 문제를 예방                         |
| 기타    | `READ`                        | -                                                                                             | -                                                             | -                                                           | -                                         |
| 기타    | `WRITE`                       | -                                                                                             | -                                                             | -                                                           | -                                         |


<br>

## 2) 2차 캐시
* **1차 캐시**: 영속성 컨텍스트 내부에 엔티티를 보관. 엔티티 매니저로 조회하거나 변경하는 모든 엔티티 저장. 트랜잭션 커밋 및 플러시를 호출하면 데이터베이스에 동기화
  * 트랜잭션을 시작하고 종료할 때까지만 1차 캐시 유효
  * 애플리케이션 전체로 보면 데이터베이스 접근 횟수를 획기적으로 줄이지는 못한다.
  * 트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고 트랜잭션을 종료할 때 영속성 컨텍스트도 종료
  * 1차 캐시는 같은 엔티티가 있으면 해당 엔티티를 그대로 반환. 동일성 보장
  * 기본적으로 영속성 컨텍스트 범위의 캐시
* **공유 캐시 (2차 캐시)**: 애플리케이션 범위의 캐시를 지원. 애플리케이션을 종료할 때까지 캐시가 유지
  * 조회 성능 향상
  * 데이터를 조회할 때 우선 2차 캐시에서 찾고 없으면 데이터베이스에서 찾음
  * 동시성을 극대화 하기 위해 객체를 반환할 때 **복사본 반환** 👉 동시성 저하
  * 영속성 유닛 범위의 캐시
  * 데이터베이스 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 객체 동일성을 보장하지 않음


<br>

### 1️⃣ 2차 캐시 기능
* `SharedCacheMode` 캐시 모드 설정

|                     | 설명                                                   | 
|---------------------|:-----------------------------------------------------|
| `ALL`               | 모든 엔티티를 캐시한다.                                        | 
| `NONE`              | 캐시를 사용하지 않는다.                                        | 
| `ENABLE_SELECTIVE`  | `Cacheable(true)`로 설정된 엔티티만 캐시를 적용한다.(사용)            | 
| `DISABLE_SELECTIVE` | 모든 엔티티를 캐시하는데 `Cacheable(false)`로 명시된 엔티티는 캐시하지 않는다. | 
| `UNSPECIFIED`       | JPA 구현체가 정의한 설정을 따른다.                                | 

<br>

### 2️⃣ 하이버네이트와 EHCACHE의 2차 캐시 적용
1. **엔티티 캐시**: 엔티티 단위로 캐시한다. 식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티를 로딩할 때 사용한다.
2. **컬렉션 캐시**: 엔티티와 연관된 컬렉션을 캐시한다. 컬렉션이 엔티티를 담고 있으면 시별자 값만 캐시한다.
3. **쿼리 캐시**: 쿼리와 파라미터 정보를 키로 사용해서 캐시한다. 결과가 엔티티면 식별자 값만 캐시한다.

#### ❶ 엔티티 캐시와 컬렉션 캐시
```java
@Cacheable      // 엔티티 캐시 사용
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)             // 캐시와 관련된 세밀한 설정 가능
@Entity
public class ParentMember {
    @Id @GeneratedValue
    private Long id;
    private String name;
    
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    @OneToMany(mappedBy = "parentMember", cascade = Cascade.ALL)
    private List<ChildMember> childMembers = new ArrayList<ChildMember>();
}
```

<br>

#### ❷ 쿼리 캐시
쿼리 캐시는 쿼리와 파라미터 정보를 키로 사용해서 쿼리 결과를 캐시하는 방법 <br>
데이터 집합을 최신 데이터로 유지하려고 쿼리 캐시를 실행하는 시간과 쿼리 캐시가 사용하는 테이블들이 가장 최근에 변경된 시간 비교(타임스탬프 조회) <br>
수정이 거의 일어나지 않는 테이블에 효과적
```java
em.createQuery("select i from i", Item.class)
    .setHint("org.hibernate.cacheable", true)
    .getResultList();

@Entity
@NamedQuery (
        hints = @QueryHint(name = "org.hibernate.cacheable",
                value = "true"),
        name = "Member.findByUsername",
        query = "select m.address from Member m where m.name = :username"
)
public class Member {
  ...
}
```

<br>

> ### 🚨 쿼리 캐시와 컬렉션 캐시의 주의 점
> * 쿼리 캐시와 컬렉션 캐시는 결과 집합의 식별자 값만 캐시
> * 따라서 조회하면 그 안에는 식별자 값만 있음 (식별자 값을 하나씩 엔티티 캐시에서 조회해서 실제 엔티티를 찾음)
> * 쿼리 캐시나 컬렉션 캐시만 사용하고 대상 엔티티에 엔티티 캐시를 적용하지 않으면 성능 문제