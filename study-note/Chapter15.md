# Chapter.15 고급 주제와 성능 최적화

> ### 📋 차례
> [1) 예외 처리](#1-예외-처리) <br>
> [2) 엔티티 비교](#2-엔티티-비교) <br>
> [3) 프록시 심화 주제](#3-프록시-심화-주제) <br>
> [4) 성능 최적화](#4-성능-최적화) <br>

<br>

## 1) 예외 처리

### 1️⃣ JPA 표준 예외 
* `RuntimeException`의 자식인 `PersistenceException`의 자식 👉 언체크 예외
  * 트랜잭션 롤백을 표시하지 않는 예외
  * 트랜잭션 롤백을 표시하는 예외(심각한 예외, 복구해서는 안됨) `RollbackException`
* 서비스에 의존하는 것을 막기 위해 스프링 프레임워크 JPA 예외로 변환 가능
  * `JavaConfig`에서 예외변환기 사용
  * 또는 직접 명시 `throws javax.persistence.NoResultException`

### 2️⃣ 트랜잭션 롤백시 주의 사항
* 트랜잭션 롤백은 데이터베이스의 반영사항만 롤백하는 것
  * 🚨 트랜잭션 롤백은 **수정한 자바 객체까지 복구하지 않는다.** 👉 **영속성 컨텍스트는 복구되지 않는다.**
  * 롤백시 `EntityManager.clear()` 필수
> ### ✅ 트랜잭션 롤백 해결방법
> 1) 트랜잭션당 영속성 컨텍스트 전략
>   * 트랜잭션 AOP 종료시점에 트랜잭션 롤백하면서 영속성 컨텍스트도 자동 종료 👉 ✅ 문제 없음
> 2) OSIV (영속성 컨텍스트 범위 > 트랜잭션 범위) 전략
>   * 트랜잭션을 종료해도 영속성 컨텍스트는 살아있으니 초기화 필요 👉 ✅ `EntityManager.clear()`

<br>

## 2) 엔티티 비교

### 1️⃣ 영속성 컨텍스트가 같을 때 엔티티 비교
* 동일성: == 비교가 같다.
* 동등성: equals() 비교가 같다.
* 데이터베이스 동등성: @Id인 데이터베이스 식별자가 같다.

### 2️⃣ 영속성 컨텍스트가 다를 때 엔티티 비교
다른 영속성 컨텍스트에서 객체를 관리하기 때문에 동등하지 않다. 👉 다른 인스턴스
* 동일성: == 비교가 실패한다.
* 동등성: equals() 비교가 같다. 비즈니스 키를 이용해 equals()를 따로 구현해야 한다.(유일성 보장)
* 데이터베이스 동등성: @Id인 데이터베이스 식별자가 같다.

<br>

## 3) 프록시 심화 주제
프록시는 원본 엔티티를 상속받아서 만들어지므로 엔티티를 사용하는 클라이언는 엔티티가 프록시인지, 원본 엔티티인지 구분하지 않고 사용할 수 있다.

### 1️⃣ 영속성 컨텍스트와 프록시
> 💬 영속성 컨텍스트가 프록시로 조회한 엔티티의 동일성도 보장하는가?

```java
Member refMember = em.getReference(Member.class, "member1");    // 프록시 조회
Member findMember = em.find(Member.class, "member1");           // ✅ 처음 프록시를 조회했으므로 프록시를 조회
```
👉 영속성 컨텍스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 **원본 엔티티가 아닌 처음 조회된 프록시 반환** <br>
👉 **프록시로 조회해도 영속성 컨텍스트는 영속 엔티티의 동일성을 보장**

```java
Member findMember = em.find(Member.class, "member1");           // 원본 엔티티 반환
Member refMember = em.getReference(Member.class, "member1");    // ✅ 처음 원본 엔티티를 조회했으므로 원본 엔티티 조회
```

<br>

### 2️⃣ 프록시 타입 비교
프록시는 원본 엔티티를 상속받아서 만들어지므로 프록시로 조회한 엔티티의 타입을 비교할 때는 `instanceof`를 사용해야 한다.

<br>

### 3️⃣ 프록시 동등성 비교
엔티티의 동등성을 비교하려면 비즈니스 키를 이용한 equals()메서드를 오버라이딩 하여 비교 <br>
🚨 비교 대상이 원본 엔티티면 문제가 없지만 프록시면 문제 발생

* 원본 엔티티와 프록시에서 가져온 원본 엔티티를 비교할 때는 `instanceof()` 사용
* 프록시의 멤버 변수는 실제 데이터를 가지고 있지 않다. 👉 getter 접근자로 비교해야 함

<br>

### 4️⃣ 상속관계와 프록시

Item(부모 엔티티)를 프록시로 조회, Book(자식 엔티티)를 원본 객체로 조회 <br>
이때, `proxyItem`은 Item 타입으로 만들어진 프록시 객체, 원본엔티티로 Book 엔티티를 참조
그러나, `proxyItem`는  Book이 아닌 Item 클래스를 기반으로 만들어짐 
```java
proxyItem instanceof Book   // false
proxyItem instanceof Item   // true
```

> #### 🚨 프록시를 부모 타입으로 조회할 경우 문제
> 프록시를 부모 타입으로 조회할 경우 부모 타입을 기반으로 프록시가 생성됨
> 1) `instanceof` 연산을 사용할 수 없다.
> 2) 하위 타입으로 다운 캐스팅 할 수 없다.

> #### ✅ 프록시를 부모 타입으로 조회할 경우 해결 방법
> 1) JPQL로 대상 직접 조회
>    * 처음부터 자식 타입을 직접 조회 👉 🚨 다형성 활용 불가
> 2) 프록시 벗기기 `unProxy(item)`
>    * 영속성 컨텍스트는 먼저 프록시로 조회하면 계속 프록시로 조회한다. (영속 엔티티의 동일성 보장)
>    * 프록시에서 원본 엔티티를 직접 조회 👉 🚨 프록시와 원본 엔티티의 동일성 비교 실패
> 3) 기능을 위한 별도의 인터페이스 제공
>    * 클라이언트 입장에서 대상 객체가 프록시인지 아닌지 고민하지 않아도 됨
> ```java
> public interface TitleView {
>     String getTitle();        // 자식 엔티티에서 구현
> }
> ``` 
> 4) 비지터 패턴 사용 `Visitor Pattern`
>    * `accept(visitor)` 메서드를 사용해서 `Visitor`를 받아들인다.
>    * 부모 엔티티는 단순히 `Visitor`를 받아들이기만 하고 실제 로직은 `Visitor`가 처리
>    * 원본 데이터용 getName() 사용하여 비교
>      * `PrintVisitor`: 대상 클래스의 내용 출력 (원본 엔티티)
>      * `TitleVisitor`: 대상 클래스의 제목 출력
>    * 비지터 패턴은 기존 코드의 구조를 변경하지 않고 기능 추가 가능
> ```java
> @Test
> public void 상속관계와_프록시_VisitorPattern() {
>     ...
>     OrderItem orderItem = em.find(OrderItem.class, orderItemId);  // 지연로딩으로 인한 프록시 조회
>     Item item = orderItem.getItem();      // 지연로딩으로 인한 프록시 조회
>     
>     item.accept(new PrintVisitor());      // 실제 엔티티로 제목 출력
> }
> ```
> > #### 📢 비지터 패턴의 장점과 단점
> > #### ✅ 장점
> > * 프록시에 대한 걱정없이 안전하게 원본 엔티티에 접근 간으
> > * instanceof와 타입캐스팅 없이 코드 구현 가능
> > * 알고리즘과 객체 구조를 분리해서 구조를 수정하지 않고 새로운 동작 추가 가능
> > #### 🚨단점
> > * 너무 복잡하고 더블 디스패치를 사용하기 때문에 이해가 어려움
> > * 객체 구조가 변경되면 모든 Visitor를 수정해야 함

<br>

## 4) 성능 최적화
### 1️⃣ N+1 문제

#### 🚨 문제 상황
1) 즉시 로딩: 한번의 SQL로 회원과 주문정보를 함께 조회
   * 회원 엔티티를 먼저 조회(JPQL)하고 이후 각 회원의 주문을 조회할 때 N+1 문제 발생 🚨
2) 지연 로딩
   * 회원 엔티티만 조회 이후 각 주문 컬렉션을 초기화 및 조회할 때 N+1 문제 발생 🚨

#### ✅ 해결 방법
1) <ins>**페치 조인 사용**</ins>
   * 페치 조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조회 👉 N+1 문제가 발생하지 않음
   * `select m from Member m join fetch m.orders` (`DISTINCT` 사용으로 중복제거 필요)
2) <ins>**하이버네이트 `@BatchSize`**</ins>
   * 연관된 엔티티를 조회할 떄 지정한 size 만큼 **SQL의 IN절을 사용**하여 조회
3) <ins>**하이버네이트 `@Fetch(FetchMode.SUBSELECT)`**</ins>
   * 연관된 데이터를 조회할 때 서브 쿼리를 사용한 IN절을 호출하여 N+1 해결

<br>

> ### 📢 N+1 정리
> 👉 <ins>**모두 지연로딩으로 설정하고 성능 최적화가 꼭 필요한 곳에는 JPQL 페치조인 사용**</ins>


<br>

### 2️⃣ 읽기 전용 쿼리의 성능 최적화
영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용한다는 단점 🚨 <br>
👉 **읽기 전용으로 엔티티 조회**

#### ✅ 해결 방법
1) <ins>**스칼라 타입으로 조회**</ins>
    * 조회시 스칼라 타입으로 모든 필드를 조회 👉 영속성 컨텍스트가 결과를 관리하지 않게됨 🚨
2) <ins>**읽기 전용 쿼리 힌트 사용**</ins> `query.setHint("org.hibernate.readOnly", true);`
    * 읽기 전용이므로 영속성 컨텍스트는 스냅샷을 보관하지 않음 👉 메모리 사용량 최적화 가능
    * 스냅샷이 없어 엔티티를 수정해도 데이터베이스에 반영되지 않음 🚨
3) <ins>**읽기 전용 트랜잭션 사용**</ins> `@Transactional(readOnly = true)`
    * 스프링 프레임 워크가 하이버네이트 세션의 플러시 모드를 `MANUAL`로 설정 👉 강제 플러시를 하지 않는한 플러시 발생하지 않음
    * 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시 하지 않아 엔티티의 등록, 수정, 삭제는 동작하지 않음
    * 플러시 할 때 일어나는 스냅샷 비교 등을 수행하지 않아 성능 향상
    * 영속성 컨텍스트를 플러시 하지 않을 뿐 트랜잭션 과정은 이루어짐
    * 엔티티 매니저의 `unwrap()`속성으로 하이버네이트 세션을 구현할 수 있음 👉`MANUAL` 모드 사용 수동 설정 가능
4) <ins>**트랜잭션 밖에서 읽기**</ins> `@Transactional(propagation = Propagation.NOT_SUPPORTED)`
    * 트랜잭션을 사용하지 않아 플러시가 발생하지 않는다.

> ### 📢 읽기 전용 최적화 방법 정리
> 1) 읽기 전용 트랜잭션 사용: 플러시를 작동하지 않도록 하여 성능 향상
>    * `@Transactional(readOnly = true)`
> 2) 읽기 전용 엔티티 사용: 엔티티를 읽기 전용으로 조회하여 메모리 절약
>    * `.setHint("org.hibernate.readOnly", true)`

<br>

### 3️⃣ 배치 처리

#### ❶ JPA 등록 배치
* 많은 엔티티를 한번에 등록할 때 메모리 부족으로 인한 오류 때문에 영속성 컨텍스트가 모두 관리해 줄 수 없다.(주기적인 플러시 필요)

#### ❷ JPA 조회 배치
1) JPA 페이징 배치 처리
2) 하이버네이트 세션을 사용한 scroll
    * 무상태 세션은 영속성 컨텍스트를 만들지 않고 2차 캐시도 사용하지 않는다.
    * 영속성 컨텍스트를 플러시하거나 초기화 하지 않아도 되며 엔티티를 수정할 때 update() 메서드를 직접 호출 해야함

<br>

### 4️⃣ SQL 쿼리 힌트 사용
SQL 힌트를 사용하려면 하이버네이트를 직접 사용해야 한다. 
```java
Session session = em.unwrap(Session.class);     // 하이버네이트 직접 사용

List<Member> list = session.createQuery("select m from Member m")
        .addQueryHint("FULL (MEMBER)")          // SQL HINT 추가
        .list();
```

<br>

### 5️⃣ 트랜잭션을 지원하는 쓰기 지연과 성능 최적화
* 쿼리를 한번에 모아서 데이터베이스로 플러시 <br>
👉 하지만 JDBC가 제공하는 SQL 배치 기능을 사용하면 SQL을 모아서 데이터베이스에 한번에 보낼 수 있지만 코드의 많은 부분을 수정해야 한다. 🚨 <br>
👉 특수한 상황에서는 JPA SQL 배치 기능을 사용한다.

* 트랜잭션을 지원하는 쓰기 지원과 변경 감지는 성능이점도 있으나 **데이터베이스에 걸리는 테이블 락 시간을 최소화**할 수 있다.